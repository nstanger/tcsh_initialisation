# Shell functions to start and stop VPNs.

declare -Ax vpn_execs vpn_args vpns_running

vpn_execs=( \
    [home]="$BREW_PREFIX/sbin/openvpn" \
    [work]="$BREW_PREFIX/bin/openconnect" \
)

vpn_args=( \
    [home]="--config ~/.vpn/stanger.org.nz.ovpn" \
    [work]="--authgroup=UO-VPN-STAFF --user=stani07p --passwd-on-stdin --background --script='~/bin/vpn' vpn.staff.otago.ac.nz < ~/.vpn/otago.ac.nz.auth > /dev/null 2>&1" \
)

vpns_running=()

function vpn-up() {
    local vpns=($@)
    [[ $#vpns -eq 0 ]] && vpns+="work"
    for v in ${(k)vpns}; do
        if [[ -z "$vpn_execs[$v]" ]]; then
            printf '%s: warning: ignoring unknown "%s" VPN\n' $funcstack[1] $v
        else
            local program=$(basename $vpn_execs[$v])
            if [[ $(pgrep $program) ]]; then
                printf '%s: warning: ignoring already running "%s" VPN\n' $funcstack[1] $v
            else
                printf '%s: starting "%s" VPN\n' $funcstack[1] $v
                eval sudo $vpn_execs[$v] $vpn_args[$v]
                # Use an associative array to track processes, as it's a
                # lot easier to add and remove items based on program name
                # than it would be with a simple array.
                [[ $(pgrep $program) ]] && vpns_running[$v]=1
            fi
        fi
    done
}

function vpn-down() {
    local vpns=($@)
    [[ $#vpns -eq 0 ]] && vpns=${(k)vpns_running}
    for v in ${=vpns}; do
        if [[ -z "$vpn_execs[$v]" ]]; then
            printf '%s: warning: ignoring unknown "%s" VPN\n' $funcstack[1] $v
        else
            local program=$(basename $vpn_execs[$v])
            # It doesn't whether the vpn is running or not. This provides
            # a handy way to reset the process tracking if it gets out of
            # whack: just keep going `vpn-down` until the status prompt
            # item disappears.
            printf '%s: shutting down "%s" VPN\n' $funcstack[1] $v
            sudo pkill -2 $program > /dev/null 2>&1
            while [[ $(pgrep "$program") ]]; do
                # Loop until the program is definitely terminated, otherwise
                # the process tracking may get out of sync and the prompt 
                # status item won't get updated. Technical danger of an
                # endless loop if the vpn process never terminates, but
                # this can be resolved with ctrl-c and a manual `kill -9`
                # of the corresponding process.
            done
            unset "vpns_running[$v]"
        fi
    done
}

function vpn-status() {
    # This can get out of sync, but it's way faster than the original
    # approach of pgrepping for the processes.
    [[ $#vpns_running -gt 0 ]] && echo '%K{202}VPN%k '
}

# Append VPN status to the prompt.
status_addons+='vpn-status'
